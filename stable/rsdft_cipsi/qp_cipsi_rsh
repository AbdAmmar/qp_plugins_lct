#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Usage:
       qp_cipsi_rsh [-f <functional>] [-m <mu>] [-p <pt2max>] [-t <thresh>]
                    [-n <ndetmax>] [-r] EZFIO_DIR

Options:
      -f <functional>  --functional=<functional>  Exchange/correlation functional.
                                                  Default=sr_pbe
      -m <mu>          --mu=<mu>                  Range-separation parameter. Default=0.5
      -p <pt2max>      --pt2max=<pt2max>          Max value of the E(PT2). Default=1.e-3
      -t <thresh>      --threshold=<thresh>       Convergence threshold on the energy.
                                                  Default=1.e-5
      -n <ndetmax>     --ndetmax=<ndetmax>        Max number of determinants.
                                                  Default=1000000
      -r               --readints                 Read integrals. Default=False
"""

import sys
import os

try:
    QP_ROOT = os.environ["QP_ROOT"]
    QP_EZFIO = os.environ["QP_EZFIO"]
except KeyError:
    print("Error: QP_ROOT environment variable not found.")
    sys.exit(1)
else:
    sys.path = [QP_EZFIO + "/Python",
                QP_ROOT + "/install/resultsFile",
                QP_ROOT + "/install",
                QP_ROOT + "/scripts"] + sys.path

os.environ["PYTHONUNBUFFERED"] = "1"

import subprocess
import atexit
from ezfio import ezfio
from docopt import docopt
import numpy as np
import scipy
from scipy import linalg


class DIIS():

    def __init__(self,mmax=6):
        self.mmax = mmax
        self.p = []
        self.e = []
        self.m = 0
        self.mmax = mmax

    def append(self,p,e):
        def update(v,l):
            if self.m >= self.mmax:
                l = l[:-1]
            return [v.flatten()]+l
        self.p = update(p,self.p)
        self.e = update(e,self.e)
        self.m = min(self.mmax, self.m+1)
        
    def next(self):
        m = self.m
        p = np.transpose(self.p)
        e = np.transpose(self.e)
        a = np.matmul(np.transpose(e),e)
        a = np.pad(a,((0,1),(0,1)), mode="constant", constant_values=-1.)
        a[m,m] = 0.
        while m > 1 and np.linalg.cond(a) > 1.e14:
            m -= 1
            a = np.pad(a[:-2,:-2],((0,1),(0,1)), mode="constant", constant_values=-1.)
            a[m,m] = 0.
        c = np.zeros((m+1,1))
        c[m,0] = -1.
        try:
            b = scipy.linalg.solve(a,c)
            result = np.matmul(p[:,0:m],b[0:m,:]).flatten()
        except np.linalg.linalg.LinAlgError:
            result = self.p[0]
        return result


def get_params(arguments):
    """Read command line arguments"""

    filename = arguments["EZFIO_DIR"]

    functional = arguments["-f"]

    if not functional:
        functional = "sr_pbe"

    if arguments["-m"]:
        mu = float(arguments["-m"])
    else:
        mu = 0.5

    if arguments["-p"]:
        pt2max = float(arguments["-p"])
    else:
        pt2max = 1.e-3

    if arguments["-n"]:
        ndetmax = int(float(arguments["-n"]))
    else:
        ndetmax = 1000000

    if arguments["-t"]:
        thresh = float(arguments["-t"])
    else:
        thresh = 1.e-12

    readints = arguments['-r']
    
    print(f"""
EZFIO      : {filename}
Functional : {functional}
mu         : {mu} 
pt2max     : {pt2max}
ndetmax    : {ndetmax}
thresh     : {thresh}
readints   : {readints}""")

    return filename, functional, mu, pt2max, ndetmax, thresh, readints 


def reset_ezfio():
    ezfio.set_ao_one_e_ints_io_ao_integrals_kinetic("None")
    ezfio.set_ao_one_e_ints_io_ao_integrals_n_e("None")
    ezfio.set_ao_two_e_ints_io_ao_two_e_integrals("None")
    ezfio.set_mo_one_e_ints_io_mo_integrals_kinetic("None")
    ezfio.set_mo_one_e_ints_io_mo_integrals_n_e("None")
    ezfio.set_mo_two_e_ints_io_mo_two_e_integrals("None")



def qp_run(command, filename):
    """Execute a qp_run command."""
    stderr = open(f"{filename}/work/error","w")
    result = subprocess.check_output(f"qp_run {command} {filename} | tee {filename}/work/output", shell=True, stderr=stderr)
    return result.decode('utf-8')



def write_effective_rsdft_hamiltonian(filename):
    output = qp_run("write_effective_rsdft_hamiltonian", filename)
    for line in output.splitlines():
        if "TOTAL ENERGY        =" in line:
            ev = float(line.split('=')[1])
            break
    return ev


def update_density(filename, diis=None):
    def get_density():
        alpha = ezfio.get_aux_quantities_data_one_e_dm_alpha_mo()
        beta  = ezfio.get_aux_quantities_data_one_e_dm_beta_mo()
        return np.array(alpha, dtype=np.double).flatten(), \
                np.array(beta, dtype=np.double).flatten()


    def set_density(alpha, beta):
        ezfio.set_aux_quantities_data_one_e_dm_alpha_mo(alpha)
        ezfio.set_aux_quantities_data_one_e_dm_beta_mo(beta)

    da, db = get_density()
    qp_run("save_one_e_dm", filename)
    da_new, db_new = get_density()
    if diis is not None:
        diis[0].append(da_new, da_new-da)
        diis[1].append(db_new, db_new-db)
        da_test=diis[0].next()
        db_test=diis[1].next()
    else:
        damp = 0.75
        da_test = damp * da_new + (1.-damp) * da
        db_test = damp * db_new + (1.-damp) * db
    set_density(da_test,db_test)


def main():
    arguments = docopt(__doc__)
    filename, functional, mu, pt2max, ndetmax, thresh, readints = \
        get_params(arguments)

    ezfio.set_file(filename)
    ezfio.set_dft_keywords_exchange_functional(functional)
    ezfio.set_dft_keywords_correlation_functional(functional) 
    ezfio.set_ao_two_e_erf_ints_mu_erf(mu)
    ezfio.set_perturbation_pt2_max(pt2max)
    ezfio.set_determinants_n_det_max(ndetmax)
    ezfio.set_density_for_dft_density_for_dft("WFT")

    atexit.register(reset_ezfio)
    
    datafile = sys.stdout

    if readints:
        pass
    else:
        qp_run("rs_ks_scf", filename)

        # Write the effective Hamiltonian containing long-range
        # interaction and short-range effective potential to be
        # diagonalized in a self-consistent way.
        # Then, save the energy of the macro-iteration.
        datafile.write("# iter Evar old     Evar new    delta_E\n")

        ev_macro = write_effective_rsdft_hamiltonian(filename)
        ezfio.set_density_for_dft_density_for_dft("input_density")

        datafile.write(f"  0 --- {ev_macro:15.10f} \n")

        diis_macro = [ DIIS(), DIIS() ]
        # Macro-iterations
        for i in range(20):
            # Run the CIPSI calculation with the effective Hamiltonian
            # already stored in the EZFIO 

            ezfio.set_determinants_read_wf(False)
            qp_run("fci", filename)

            update_density(filename, diis_macro)
            
            # Write the new effective Hamiltonian with the FCI density 
            ev = write_effective_rsdft_hamiltonian(filename) 

            diis = [ DIIS(), DIIS() ]
            # Micro-iterations
            for j in range(100):

                # Rediagonalize the new effective Hamiltonian to
                # obtain a new wave function and a new density
                qp_run("diagonalize_h", filename)

                update_density(filename,diis)

                # Write the new effective Hamiltonian with the current density 
                ev_new = write_effective_rsdft_hamiltonian(filename) 

                # Convergence
                delta_E = ev_new - ev
                datafile.write(f"{i:>3d} {j:>3d} {ev:> 15.10f} {ev_new:> 15.10f} {delta_E:> 12.6e}\n")
                ev = ev_new
                if abs(delta_E) < thresh:
                    break
                # end if

            # end for
            datafile.write("# ---\n")

            # Convergence
            delta_E = ev - ev_macro
            datafile.write(f"{i:>3d} --- {ev_macro:>15.10f} {ev:> 15.10f} {delta_E:> 12.6e}\n")
            ev_macro = ev
            if abs(delta_E) < pt2max:
                break
            # end if

        # end for

    # end if



if __name__ == '__main__':
    main()

<<<<<<< HEAD
Options:
  -m, --mu=<positive real>              range separation parameter (default=0.5)
  -f, --func=<LOWER CASE STRING>        range separated functional (default=sr_pbe)
  -n, --ndetmax=<positive integer>      max number of determinants in the CIPSI wf (default=1.e6)
  -p, --pt2max=<positive real>          max value of the PT2 correction (default=1.e-3)
  -t, --thresh=<positive real>          threshold on the convergence of the variational energy (default=1.e-10)
  -d, --damp=<positive real>            damping on the density: 0 == no density update, ==1 full density update (default=0.75)
  -r, --readints=<logical True/False>   if True: systematically reads the erf and regular bi-electronic integrals
                                        SPEEDS UP the calculation but you should pay attention 
                                        when using the EZFIO folder latter on as the integrals might not be coherent. 
                                        WARNING: can be dangerous if you interupt the calculation ...
  -h, --help                            Print the HELP message

Example:
  ./$(basename $0) -c config/gfortran.cfg


EOF
    exit
}


while true ; do
    case "$1" in
        -m|--mu) 
            case "$2" in
                "") help ; break;;
                *) mu="$2"
            esac 
            shift 2
	    ;;
        -f|--func) 
            case "$2" in
                "") help ; break;;
                *) functional="$2"
            esac 
            shift 2
	    ;;
        -n|--ndetmax) 
            case "$2" in
                "") help ; break;;
                *) ndetmax="$2"
            esac 
            shift 2
	    ;;
        -p|--pt2max) 
            case "$2" in
                "") help ; break;;
                *) pt2max="$2"
            esac 
            shift 2
	    ;;
        -t|--thresh) 
            case "$2" in
                "") help ; break;;
                *) thresh="$2"
            esac 
            shift 2
	    ;;
        -d|--damp) 
            case "$2" in
                "") help ; break;;
                *) damp="$2"
            esac 
            shift 2
	    ;;
        -r|--readints) 
            case "$2" in
                "") help ; break;;
                *) readints="$2"
            esac 
            shift 2
	    ;;
        -h|-help|--help) 
            help
            exit 0;;
        --) shift  ; break ;;
	"") help ; break ;;
    esac
done

ezfio=${1%/} # take off the / at the end

if [[ -z $ezfio ]]; then
   echo "You did not specify any input EZFIO folder ! "
   echo "stopping ..."
   echo "run $0 --help to have information on how to run the script !"
   echo "......"
   echo "......"
   exit
fi

echo "  **********"
echo "Here are the following INPUT parameters for the RSH-CIPSI run .."
echo "  **********"
echo "EZFIO folder         :  "$ezfio 
if [[ ! -d $ezfio ]]; then
   echo "Input EZFIO folder does not exists !"
   echo "Folder $ezfio does not exist."
   echo "stopping ..."
   echo "......"
   echo "......"
   echo "......"
   exit
fi
# define the exchange / correlation functionals to be used in RS-DFT calculation
if [[ -z $functional ]]; then
 echo "you did not specify the \$functional parameter, it will be set to sr_pbe by default (run --help for explanations)"
 functional="sr_pbe"
fi
echo "FUNCTIONAL for RS-DFT:  "$functional
# splitting of the interaction to be used in RS-DFT calculation 
if [[ -z $mu ]]; then
 echo "you did not specify the \$mu parameter, it will be set to 0.5 by default (run --help for explanations)"
 mu=0.5
fi
echo "MU for RS-DFT        :  "$mu
# maximum value of the PT2 for the CIPSI calculation (note that it is with the effective hamiltonian so it can be self-consistent)
if [[ -z $pt2max ]]; then
 echo "you did not specify the \$pt2max parameter, it will be set to 0.001 by default (run --help for explanations)"
 pt2max=0.001
fi
echo "PT2MAX for RS-DFT    :  "$pt2max
# ndetmax  : maximum size of the CIPSI wave function 
if [[  -z $ndetmax ]]; then
 echo "you did not specify the \$ndetmax parameter, it will be set to 10000000 by default (run --help for explanations)"
 ndetmax=10000000
fi
echo "NDETMAX for RS-DFT   :  "$ndetmax

# value of the convergence of the energy for the self-consistent CIPSI calculation at a given number of determinant
if [[ -z $thresh ]]; then
 echo "you did not specify the \$thresh parameter, it will be set to 0.001 by default (run --help for explanations)"
 thresh=${pt2max}
fi
echo "thresh of convergence:  "$thresh

# value of the damping factor for the density 
if [[ -z $damp ]]; then
 echo "you did not specify the \$damp parameter, it will be set to 0.75 by default (run --help for explanations)"
 damp="0.75"
fi
echo "damping factor       :  "$damp  
dampsave=$damp

# readints: true or false to read the integrals 
if [[  -z $readints ]]; then
 echo "you did not specify the \$readints parameter, it will be set to False by default (run --help for explanations)"
 readints="False"
fi
echo "READINTS             :  "$readints

qp set_file $ezfio

qp  set  dft_keywords       exchange_functional     "${functional}"
qp  set  dft_keywords       correlation_functional  "${functional}"
qp  set  ao_two_e_erf_ints  mu_erf                  $mu
qp  set  perturbation       pt2_max                 $pt2max
qp  set  determinants       n_det_max               $ndetmax
# Use the wave function stored in the EZFIO to build effective RS-DFT potential
qp  set  density_for_dft    density_for_dft         "WFT"
qp  set  density_for_dft    damping_for_rs_dft      $damp


if [[ $readints = "False" ]]; then
# write the effective Hamiltonian containing long-range interaction and short-range effective potential to be diagonalized in a self-consistent way
  echo "#" iter evar old     evar new    deltae      threshold  > ${ezfio}_data_rsdft-${mu}-${functional}
  qp run write_effective_rsdft_hamiltonian | tee ${ezfio}/work/rsdft-${mu}-${functional}-0
  EV_macro=`grep "TOTAL ENERGY        =" ${ezfio}/work/rsdft-${mu}-${functional}-0 | cut -d "=" -f 2`
# save the RS-KS one-e density for the damping on the density 
  qp run save_one_e_dm 

  qp  set  density_for_dft    density_for_dft         "damping_rs_dft"
# damping_for_rs_dft : 0 == no update of the density, 1 == full update of the density 


#  for i in {1..100}
  for i in 1
   do
#  run the CIPSI calculation with the effective Hamiltonian already stored in the EZFIO folder 
     qp set determinants read_wf "False"
     qp run fci  | tee ${ezfio}/work/fci-${mu}-${functional}-$i
     EV=0

     echo "#" iter evar old     evar new    deltae      threshold  >> ${ezfio}/work/data_conv-${mu}-${functional}-${i}
     for j in {1..100}
     do
        # write the new effective Hamiltonian with the damped density (and the current density to be damped with the next density)
        qp run write_effective_rsdft_hamiltonian | tee ${ezfio}/work/rsdft-${mu}-${functional}-${i}-${j}
        # value of the variational RS-DFT energy 
        EV_new=`grep "TOTAL ENERGY        =" ${ezfio}/work/rsdft-${mu}-${functional}-${i}-${j} | cut -d "=" -f 2`
        # rediagonalize the new effective Hamiltonian to obtain a new wave function and a new density 
        qp run diagonalize_h  | tee ${ezfio}/work/diag-${mu}-${functional}-${i}-${j}
        # checking the convergence
        DE=`echo "${EV_new} - ${EV}" | bc`
        DEabs=`echo "print(abs(${DE}))" | python `
        CONV=`echo  "print(${DEabs} < ${thresh})" | python`
        echo $j $EV $EV_new $DE $thresh >> ${ezfio}/work/data_conv-${mu}-${functional}-${i}
        if [ "$CONV" = "True" ]; then
          break
        fi
        EV=$EV_new
      done
     
      qp run  write_effective_rsdft_hamiltonian | tee ${ezfio}/work/rsdft-${mu}-${functional}-${i}-final
      EV_new_macro=`grep "TOTAL ENERGY        =" ${ezfio}/work/rsdft-${mu}-${functional}-${i}-final | cut -d "=" -f 2`
      # checking the convergence
      DE=`echo "${EV_new_macro} - ${EV_macro}" | bc`
      DEabs=`echo "print(abs(${DE}))" | python `
      CONV=`echo "print(${DEabs} < ${thresh})" | python`
      echo $i $EV_macro $EV_new_macro $DE $thresh >> ${ezfio}_data_rsdft-${mu}-${functional}
      if [ "$CONV" = "True" ]; then
        break
      fi
      EV_macro=$EV_new_macro
  done

else 

# write the effective Hamiltonian containing long-range interaction and short-range effective potential to be diagonalized in a self-consistent way
  echo "#" iter evar old     evar new    deltae      threshold  > ${ezfio}_data_rsdft-${mu}-${functional}
  qp run write_erf_and_regular_ints 
  for file in consolidated_idx consolidated_key consolidated_value
   do 
    cp ${ezfio}/work/work/mo_ints_regular_$file ${ezfio}/work/work/mo_ints_$file
   done
  qp run write_rsdft_h_read_ints | tee ${ezfio}/work/rsdft-${mu}-${functional}-0
  EV_macro=`grep "TOTAL ENERGY        =" ${ezfio}/work/rsdft-${mu}-${functional}-0 | cut -d "=" -f 2`
# save the RS-KS one-e density for the damping on the density 
  qp run save_one_e_dm 

  qp  set  density_for_dft    density_for_dft         "damping_rs_dft"
# damping_for_rs_dft : 0 == no update of the density, 1 == full update of the density 
  qp  set  density_for_dft    damping_for_rs_dft      0.75

  for i in {1..1000}
   do
#  run the CIPSI calculation with the effective Hamiltonian already stored in the EZFIO folder 
     qp set determinants read_wf "False"
     # save the erf integrals into the two-elec file
     for file in consolidated_idx consolidated_key consolidated_value
      do 
       cp ${ezfio}/work/work/mo_ints_erf_$file ${ezfio}/work/work/mo_ints_$file
      done
     qp run fci  | tee ${ezfio}/work/fci-${mu}-${functional}-$i
#     qp run cisd  | tee ${ezfio}/work/fci-${mu}-$i
     EV=0

     echo "#" iter evar old     evar new    deltae      threshold  >> ${ezfio}/work/data_conv-${mu}-${functional}-${i}
     for j in {1..100}
     do
        # save the regular integrals into the two-elec file
        for file in consolidated_idx consolidated_key consolidated_value
         do 
          cp ${ezfio}/work/work/mo_ints_regular_$file ${ezfio}/work/work/mo_ints_$file
         done
        # write the new effective Hamiltonian with the damped density (and the current density to be damped with the next density)
        qp run write_rsdft_h_read_ints | tee ${ezfio}/work/rsdft-${mu}-${functional}-${i}-${j}
        # value of the variational RS-DFT energy 
        EV_new=`grep "TOTAL ENERGY        =" ${ezfio}/work/rsdft-${mu}-${functional}-${i}-${j}| cut -d "=" -f 2`

        # save the erf integrals into the two-elec file
        for file in consolidated_idx consolidated_key consolidated_value
         do 
          cp ${ezfio}/work/work/mo_ints_erf_$file ${ezfio}/work/work/mo_ints_$file
         done
        # rediagonalize the new effective Hamiltonian to obtain a new wave function and a new density 
        qp run diagonalize_h  | tee ${ezfio}/work/diag-${mu}-${functional}-${i}-${j}
        # checking the convergence
        DE=`echo "${EV_new} - ${EV}" | bc`
        DEabs=`echo "print(abs(${DE}))" | python `
        neg=`echo "print(${DE} <= 0.)" | python`
        if [[ ! "$neg" = "True" ]]; then
         qp  set  density_for_dft    density_for_dft         "input_density"
######## damping_for_rs_dft : 0 == no update of the density, 1 == full update of the density 
         qp  set  density_for_dft    damping_for_rs_dft      ${damp} * 0.5 
        else 
         qp  set  density_for_dft    density_for_dft         "damping_rs_dft"
         damp=$dampsave
        fi
        CONV=`echo "print(${DEabs} < ${thresh})" | python`
        echo $j $EV $EV_new $DE $thresh >> ${ezfio}/work/data_conv-${mu}-${functional}-${i}
        if [ "$CONV" = "True" ]; then
          break
        fi
        EV=$EV_new
      done
     
      # save the regular integrals into the two-elec file
      for file in consolidated_idx consolidated_key consolidated_value
       do 
        cp ${ezfio}/work/work/mo_ints_regular_$file ${ezfio}/work/work/mo_ints_$file
       done
      qp run  write_rsdft_h_read_ints | tee ${ezfio}/work/rsdft-${mu}-${functional}-${i}-final
      EV_new_macro=`grep "TOTAL ENERGY        =" ${ezfio}/work/rsdft-${mu}-${functional}-${i}-final  | cut -d "=" -f 2`
      # checking the convergence
      DE=`echo "${EV_new_macro} - ${EV_macro}" | bc`
      DEabs=`echo "print(abs(${DE}))" | python `
      CONV=`echo "print(${DEabs}) < ${thresh}" | python`
      echo $i $EV_macro $EV_new_macro $DE $thresh >> ${ezfio}_data_rsdft-${mu}-${functional}
      if [ "$CONV" = "True" ]; then
        break
      fi
      EV_macro=$EV_new_macro
     
  done



fi
=======
>>>>>>> 5d881bb9369702ebfabbdbce4a4a9916655bc1b1
